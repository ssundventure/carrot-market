# Carrot Market

프론트엔드 개발을 진행하며 학습한 개념과 사용 기술을 정리합니다.

---

## 📌 사용 기술

### 🚀 Tailwind CSS

- 유틸리티 퍼스트 CSS 프레임워크로, 빠르고 직관적인 스타일링이 가능하다.
- 클래스 기반 스타일링을 활용하여 유지보수성과 생산성을 향상할 수 있다.

### 🚀 Zod

- `server action`으로 전달되는 데이터의 유효성을 검사하는 라이브러리.
- 유효성 검사를 위해 **Schema(스키마)를 정의**하여 코드의 안정성을 높인다.

### 🚀 Prisma


---

## 📚 알게 된 개념

### ⚡ Server Action이란?, useFormState와의 관계

#### ✅ Server Action이란?

- Server Action은 Next.js의 서버에서 실행되는 함수를 의미한다.
- 주로 폼 데이터를 서버로 보내고 처리하는 방식에서 사용된다.
- **즉, server action은 Next.js의 서버 함수 실행 패턴을 뜻한다.**

#### ✅ Server Action과 useFormState의 관계

- useFormState는 Server Action을 호출하는 클라이언트 훅이다.
- 즉, useFormState를 통해 Server Action을 실행하고, 응답으로 상태를 관리하는 방식이다.

`const [state, action] = useFormState(createAccount, null);`

- 여기서 createAccount는 Server Action(서버에서 실행되는 함수)
- useFormState는 해당 액션을 크라이언트에서 호출하고 상태를 관리하는 역할

#### ✅ Zod + Server Action 함께 사용하는 이유

- 폼 데이터를 서버로 전송하기 전에 Zod로 유효성 검사
- 검증된 데이터를 Server Action에서 받아 처리

* Zod가 서버에서 실행되는 이유

1. Zod 검증은 서버에서 실행되어 보안성을 높임.
2. 클라이언트에서 직접 유효성 검사를 우회할 수 없도록 보호
3. 서버에서 데이터베이스 저장, 인증 처리등의 작업을 수행 가능

즉, **server action을 활용하면 Zod 유효성 검사와 백엔드 로직을 통합할 수 있다.**

---

### ⚡ Hydration

#### ✅ Hydration이란?

- **하이드레이션(Hydration)**은 서버에서 렌더링된 HTML을 클라이언트에서 React가 다시 활성화하는 과정이다.

#### ✅ Hydration이 필요한 이유

Next.js와 같은 SSR 프레임워크에서는,

1. **서버에서 HTML을 미리 생성**하여 클라이언트에 전달한다.
2. **클라이언트에서 React가 이벤트 핸들러 등을 연결**하여 인터랙션을 가능하게 만든다.

이 과정을 통해 **서버에서 빠르게 초기 화면을 표시**하고, 이후에 React가 인터랙티브한 기능을 활성화하는 방식이다.

#### ✅ Hydration 오류 발생 이유

- **서버에서 렌더링된 HTML과 클라이언트에서 렌더링된 HTML이 일치하지 않으면 오류 발생**
- 예를 들어, `Math.random()` 같은 동적인 값이 포함되면 **서버와 클라이언트의 값이 다르게 생성**되어 Hydration 오류가 발생할 수 있다.

#### ✅ Hydration 오류 해결 방법

- **`useEffect`를 활용하여 클라이언트에서만 실행되는 로직을 분리**한다.
- `useEffect`는 Hydration이 끝난 후 실행되므로, 서버와 클라이언트가 동일한 UI를 유지할 수 있다.

---

### ⚡ useFormState, useFormStatus

#### ✅ state와 status 의 의미

- **state(상태)**
  -- **특정 시점**의 값을 의미한다.
  -- 예를들어 폼 필드의 값, 입력된 텍스트, 유효성 검사 결과 등을 포함한다.

- **status(진행상태)**
  -- **일련의 과정 중 특정 상태**를 의미한다.
  -- 예를들어 **폼이 제출중인지, 에러가 발생했는지, 제출이 완료되었는지** 등의 상태를 나타낸다.

💡 즉, state는 현재 입력상태를 추적하고, status는 제출 상태를 관리한다.

#### ✅ `useFormState`

##### 언제 사용할까?

-- 폼의 값과 에러 상태를 관리하고 싶을 떄 사용한다.
-- 예를들어 입력값이 **유효한지 확인하고, 오류 메세지를 표시 할 때** 적합하다.
💡 **즉, useFormState는 폼 입력값의 상태와 유효성 검사 오류를 관리하는 훅이다.**

#### ✅ `useFormStatus`

##### 언제 사용할까?

-- 폼이 제출 중인지, 제출 완료되었는지, 버튼을 비활성화해야하는지 등을 관리할 때 사용한다.
-- 로딩 스피너, 버튼 비활성화, 성공 메세지 표시 등에 활용한다.

💡 **즉, useFormStatus는 폼의 제출 상태를 추적하고 UI를 업데이트하는 역할이다.**

---

### ⚡ TypeScript의 `any` vs `unknown`

- **둘 다 모든 타입을 허용하지만 차이가 있다.**
  | 타입 | 설명 |
  |-----------|----------------------------------------|
  | `any` | 어떤 연산도 가능하지만, 타입 안정성이 떨어진다. |
  | `unknown` | 타입이 확인되지 않으면 사용이 불가능하다. |

✅ **가능하면 `unknown`을 사용하여 타입 안정성을 유지하는 것이 권장됨**.

---

### HTML 시맨틱 태그: `<main>`, `<section>`, `<article>`

| 태그            | 역할                                       |
| --------------- | ------------------------------------------ |
| **`<main>`**    | 페이지의 주요 콘텐츠 전체를 감싸는 역할    |
| **`<section>`** | 연관된 콘텐츠 그룹을 나누는 역할           |
| **`<article>`** | 독립적인 콘텐츠 (예: 블로그 글, 뉴스 기사) |

---
### console.log의 + , 연산자의 차이

| 연산자 | 용도                          | 결과                                                   |
| ------ | -------------------------- | ------------------------------------------------------ |
| `+`    | 문자열 결합                   | 객체를 문자열로 변환 → `[object Object]`               |
| `,`    | `console.log`의 다중 인자 전달 | 객체 구조 그대로 출력 (콘솔에서 트리 형태로 확인 가능) |

---
---

💡 **이 README는 지속적으로 업데이트됩니다.**
